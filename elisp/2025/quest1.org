
* Part I
There's something remarkable about the eggshell you hatched from. Faintly glowing dots and lines cover its entire surface. Even stranger is the fact that you understand what they mean! Is it a unique language that all members of your species are born knowing?
After taking a closer look, it turns out that the eggshell has three separate sections. Each section contains a list of names and a list of instructions specifying how to navigate through the list of names. Before executing the first instruction, you are at the first name of the list. Each instruction begins with the letter

 R 

or

 L 

, followed by a certain number, which simply indicates how many positions to move to the (R)ight or to the (L)eft from your current position.
You're taking a closer look at the first section ( your notes ). The description says that if you can't follow the full instruction without going off the list, you do as many moves as you can to stay on it. For example, if the next instruction is

 L3 

and you are at the second name of the list, you move only one position to the left. The description additionally states that the name you land on at the end of the entire process represents the name of the dragonduck inside the egg! So, you're a dragonduck, and you'll find out your name soon!
Example based on the following notes:

Vyrdax,Drakzyph,Fyrryn,Elarzris

R3,L2,R3,L1

Start at the first name on the list: Vyrdax:

  ↓
Vyrdax  Drakzyph  Fyrryn  Elarzris

The first instruction is

 R3 

, so you move three positions to the right, landing on Elarzris:

                             ↓
Vyrdax  Drakzyph  Fyrryn  Elarzris

The next instruction is

 L2 

, so you move two positions to the left, landing on Drakzyph:

           ↓
Vyrdax  Drakzyph  Fyrryn  Elarzris

The next instruction is

 R3 

, but the list is too short for that move. Instead, you move as far as possible - to Elarzris:

                             ↓
Vyrdax  Drakzyph  Fyrryn  Elarzris

The final instruction is

 L1 

, moving one position left to

 Fyrryn 

. This is where the process ends:

                    ↓
Vyrdax  Drakzyph  Fyrryn  Elarzris


> how to read content from file and split by newline in emacs

⏺ Here are the common ways to read a file and split by newlines in Emacs Lisp:

  Simple: Read entire file and split

  ;; Read file into a list of lines
  (with-temp-buffer
    (insert-file-contents "path/to/file.txt")
    (split-string (buffer-string) "\n" t))

  The third argument t to split-string omits empty strings (trailing newlines).

  Alternative: Using f.el library (if available)

  ;; Requires f.el library
  (f-read-lines "path/to/file.txt")

  Manual line-by-line reading

  ;; Read lines into a list manually
  (with-temp-buffer
    (insert-file-contents "path/to/file.txt")
    (let ((lines '()))
      (goto-char (point-min))
      (while (not (eobp))
        (push (buffer-substring-no-properties
               (line-beginning-position)
               (line-end-position))
              lines)
        (forward-line 1))
      (nreverse lines)))

  Read entire file as string (no splitting)

  ;; Just get the file contents as a string
  (with-temp-buffer
    (insert-file-contents "path/to/file.txt")
    (buffer-string))

  Common pattern for Advent of Code style problems

  (defun read-input (filename)
    "Read FILENAME and return list of lines."
    (with-temp-buffer
      (insert-file-contents filename)
      (split-string (buffer-string) "\n" t)))

  ;; Usage
  (let ((lines (read-input "data/2024/day1.txt")))
    (mapcar #'string-to-number lines))

  The with-temp-buffer + insert-file-contents + split-string pattern is the most common and idiomatic approach in Emacs Lisp.
  
		    #+begin_src elisp
  (with-temp-buffer
    (insert-file-contents "../../data/2025/quest1.txt")
    (split-string (buffer-string) "\n" t))		      
#+end_src

#+RESULTS:
| Dalkryth,Fengnaris,Urnor,Zarathzal,Aelithfal,Karthris,Yndnylor,Tharnrilor,Adalsarix,Nyralis | L6,R1,L9,R7,L1,R7,L1,R2,L9,R7,L9 |


** How to read file and split by line and assign first and second element to varaible in emacs lisp

⏺ Here are several ways to read a file, split by lines, and extract first/second elements in Emacs Lisp:

  Using let with car and cadr

  (let* ((lines (with-temp-buffer
                  (insert-file-contents "path/to/file.txt")
                  (split-string (buffer-string) "\n" t)))
         (first-line (car lines))
         (second-line (cadr lines)))
    ;; Use first-line and second-line here
    (message "First: %s, Second: %s" first-line second-line))

  Using nth

  (let* ((lines (with-temp-buffer
                  (insert-file-contents "path/to/file.txt")
                  (split-string (buffer-string) "\n" t)))
         (first-line (nth 0 lines))
         (second-line (nth 1 lines)))
    (message "First: %s, Second: %s" first-line second-line))

  Destructuring with pcase-let (modern Emacs)

  (pcase-let ((`(,first ,second . ,_rest)
               (with-temp-buffer
                 (insert-file-contents "path/to/file.txt")
                 (split-string (buffer-string) "\n" t))))
    (message "First: %s, Second: %s" first second))

  Using seq-let (Emacs 25+)

  (seq-let [first second]
      (with-temp-buffer
        (insert-file-contents "path/to/file.txt")
        (split-string (buffer-string) "\n" t))
    (message "First: %s, Second: %s" first second))

  Splitting each line into words

  If you want to split each line by spaces and get first/second words:

  (let* ((lines (with-temp-buffer
                  (insert-file-contents "path/to/file.txt")
                  (split-string (buffer-string) "\n" t)))
         (first-line (car lines))
         (words (split-string first-line))
         (first-word (car words))
         (second-word (cadr words)))
    (message "First word: %s, Second word: %s" first-word second-word))

  Processing all lines with first/second columns

  (defun process-file (filename)
    (let ((lines (with-temp-buffer
                   (insert-file-contents filename)
                   (split-string (buffer-string) "\n" t))))
      (dolist (line lines)
        (let* ((parts (split-string line))
               (first (car parts))
               (second (cadr parts)))
          (message "Line: %s | %s" first second)))))

  (process-file "data/2024/day1.txt")

  Complete Advent of Code example

  (defun solve-day1 (filename)
    (let* ((lines (with-temp-buffer
                    (insert-file-contents filename)
                    (split-string (buffer-string) "\n" t)))
           (first-line (car lines))
           (second-line (cadr lines)))
      ;; Process first and second lines
      (list first-line second-line)))

  (solve-day1 "data/2024/day1.txt")

  Key functions

  - car - first element (head)
  - cadr - second element (equivalent to (car (cdr list)))
  - caddr - third element
  - nth n list - nth element (0-indexed)
  - split-string - split string by delimiter

  The let* form is useful when later bindings depend on earlier ones.

#+begin_src elisp
 (let* ((lines (with-temp-buffer
                  (insert-file-contents "../../data/2025/quest1.txt")
                  (split-string (buffer-string) "\n" t)))
         (first-line (car lines))
         (second-line (cadr lines)))
    ;; Use first-line and second-line here
    (message "First: %s, Second: %s" first-line second-line))  
#+end_src

#+RESULTS:
: First: Dalkryth,Fengnaris,Urnor,Zarathzal,Aelithfal,Karthris,Yndnylor,Tharnrilor,Adalsarix,Nyralis, Second: L6,R1,L9,R7,L1,R7,L1,R2,L9,R7,L9

#+begin_src elisp
 (seq-let [first second names moves]
      (with-temp-buffer
        (insert-file-contents  "../../data/2025/quest1.txt")
        (split-string (buffer-string) "\n" t))
    (message "First: %s, Second: %s" first second))
  
#+end_src

#+RESULTS:
: First: Dalkryth,Fengnaris,Urnor,Zarathzal,Aelithfal,Karthris,Yndnylor,Tharnrilor,Adalsarix,Nyralis, Second: L6,R1,L9,R7,L1,R7,L1,R2,L9,R7,L9

#+begin_src elisp
(if (< 5 11) 0 (- 5 11))  
#+end_src

#+RESULTS:
: 0

#+begin_src elisp
(min 3 6)  
#+end_src

#+RESULTS:
: 3

#+begin_src elisp
   (defun process-directions (directions length')
          "Process lis
    t of direction strings. L subtracts, R adds."
        (seq-reduce
         (lambda (acc dir)
           (let* ((direction (substring dir 0 1))
                  (number (string-to-number (substring dir 1))))
             (if (string= direction "L")
                 (if (> acc number) (- acc number) 0)
               (min (+ acc number) length')))
         directions
         0 )
        ))  
#+end_src

#+begin_src elisp

  (defun process-directions (directions max-length)
    "Process list of direction strings. L subtracts, R adds."
    (seq-reduce
     (lambda (acc dir)
       (let* ((direction (substring dir 0 1))
              (number (string-to-number (substring dir 1))))
         (if (string= direction "L")
             (if (> acc number) (- acc number) 0)
           (min (+ acc number) max-length))))
     directions
     0))  
#+end_src

#+RESULTS:
: process-directions

#+begin_src elisp

   
  (defun process-directions (directions max-length)
    "Process list of direction strings. L subtracts, R adds."
    (seq-reduce
     (lambda (acc dir)
       (let* ((direction (substring dir 0 1))
              (number (string-to-number (substring dir 1))))
         (if (string= direction "L")
             (if (> acc number) (- acc number) 0)
           (min (+ acc number) max-length))))
     directions
     0))  
    (let* ((lines (with-temp-buffer
                    (insert-file-contents "../../data/2025/quest1-part1.txt")
                    (split-string (buffer-string) "\n" t)))
           (first-line (car lines))
           (second-line (cadr lines))
           (first-parts (split-string first-line ","))
           (second-parts (split-string second-line ","))
           (names-len (length first-parts))
    	 )
      ;; Use first-parts and second-parts here
      ;;(message "First line parts: %S" first-parts)
     (message "Second line parts: %S" (nth (mod (process-directions second-parts (- names-len 1)) names-len) first-parts)
      ))  
      #+end_src

#+RESULTS:
: Second line parts: "Quarnzar"


#+begin_src elisp
  (defun process-directions (directions max-length)
    "Process list of direction strings. L subtracts, R adds."
    (seq-reduce
     (lambda (acc dir)
       (let* ((direction (substring dir 0 1))
              (number (string-to-number (substring dir 1))))
         (if (string= direction "L")
              (- acc number)
           (+ acc number) )))
     directions
     0))  
    (let* ((lines (with-temp-buffer
                    (insert-file-contents "../../data/2025/quest1-part2.txt")
                    (split-string (buffer-string) "\n" t)))
           (first-line (car lines))
           (second-line (cadr lines))
           (first-parts (split-string first-line ","))
           (second-parts (split-string second-line ","))
           (names-len (length first-parts))
    	 )
      ;; Use first-parts and second-parts here
      ;;(message "First line parts: %S" first-parts)
     (message "Second line parts: %S" (nth (mod (process-directions second-parts (- names-len 1)) names-len) first-parts)
      ))  
#+end_src


#+RESULTS:
: Second line parts: "Zyrixeldrin"

#+begin_src python  :results output
def to_delta(s):
    d = s[0]
    n = int(s[1:])
    return -n if d == "L" else n


def load_file(part):
    with open(f"../../data/2025/quest2.txt") as f:
        lines = f.read().splitlines()
    name_str, _, dir_str = lines
    names = name_str.split(",")
    dirs = dir_str.split(",")
    return names, list(map(to_delta,dirs))


names, dirs = load_file(1)
i = 0
for delta in dirs:
    i += delta
    if i < 0:
        i = 0
    if i >= len(names):
        i = len(names) - 1
print(names[i])

names, dirs = load_file(2)
i = sum(dirs) % len(names)
print(names[i])

names, dirs = load_file(3)
for delta in dirs:
    delta %= len(names)
    names[0], names[delta] = names[delta], names[0]
print(names[0])
#+end_src

#+RESULTS:
: Oronelor
: Mornfeth
: Auremirath


* How to swap two elements in list by index in emacs lisp

⏺ Here are several ways to swap two elements in a list by index in Emacs Lisp:

  Functional approach (creating new list)

  #+begin_src elisp

  (defun swap-elements (lst i j)
    "Return new list with elements at indices I and J swapped."
    (let ((elem-i (nth i lst))
          (elem-j (nth j lst)))
      (mapcar (lambda (idx)
                (cond
                 ((= idx i) elem-j)
                 ((= idx j) elem-i)
                 (t (nth idx lst))))
              (number-sequence 0 (1- (length lst))))))

  ;; Test
  (swap-elements '(a b c d e) 1 3)
  ;; => (a d c b e)
  #+end_src

#+RESULTS:
| a | d | c | b | e |

  More efficient functional approach

  (defun swap-elements (lst i j)
    "Return new list with elements at indices I and J swapped."
    (when (> i j)
      (let ((temp i))
        (setq i j)
        (setq j temp)))
    (let ((elem-i (nth i lst))
          (elem-j (nth j lst))
          (result '())
          (idx 0))
      (dolist (elem lst (nreverse result))
        (cond
         ((= idx i) (push elem-j result))
         ((= idx j) (push elem-i result))
         (t (push elem result)))
        (setq idx (1+ idx)))))

  ;; Test
  (swap-elements '(a b c d e) 1 3)
  ;; => (a d c b e)

  Destructive approach (modifies original list)

  (defun swap-elements! (lst i j)
    "Destructively swap elements at indices I and J in LST."
    (let ((pos-i (nthcdr i lst))
          (pos-j (nthcdr j lst)))
      (when (and pos-i pos-j)
        (let ((temp (car pos-i)))
          (setcar pos-i (car pos-j))
          (setcar pos-j temp))))
    lst)

  ;; Test
  (let ((my-list '(a b c d e)))
    (swap-elements! my-list 1 3)
    my-list)
  ;; => (a d c b e)

  Using seq library (modern approach)

  (defun swap-elements (lst i j)
    "Return new list with elements at indices I and J swapped."
    (let* ((vec (vconcat lst))  ; Convert to vector for O(1) access
           (temp (aref vec i)))
      (aset vec i (aref vec j))
      (aset vec j temp)
      (append vec nil)))  ; Convert back to list

  ;; Test
  (swap-elements '(a b c d e) 1 3)
  ;; => (a d c b e)

  Clean and simple version

  (defun swap-elements (lst i j)
    "Return new list with elements at I and J swapped."
    (let ((elem-i (nth i lst))
          (elem-j (nth j lst))
          (idx 0)
          (result '()))
      (dolist (elem lst (nreverse result))
        (push (cond ((= idx i) elem-j)
                    ((= idx j) elem-i)
                    (t elem))
              result)
        (setq idx (1+ idx)))))

  ;; Test
  (swap-elements '(a b c d e) 1 3)
  ;; => (a d c b e)

  (swap-elements '(10 20 30 40 50) 0 4)
  ;; => (50 20 30 40 10)

  Practical example with numbers

  (defun swap-elements (lst i j)
    "Return new list with elements at I and J swapped."
    (let ((elem-i (nth i lst))
          (elem-j (nth j lst))
          (idx 0)
          (result '()))
      (dolist (elem lst (nreverse result))
        (push (cond ((= idx i) elem-j)
                    ((= idx j) elem-i)
                    (t elem))
              result)
        (setq idx (1+ idx)))))

  ;; Examples
  (swap-elements '(1 2 3 4 5) 0 4)
  ;; => (5 2 3 4 1)

  (swap-elements '("L6" "R1" "L9" "R7") 1 2)
  ;; => ("L6" "L9" "R1" "R7")

  Key differences:

  | Approach        | Modifies original? | Performance | Notes                                |
  |-----------------|--------------------|-------------|--------------------------------------|
  | Functional      | No                 | O(n)        | Safe, returns new list               |
  | Destructive (!) | Yes                | O(n)        | Faster, but modifies input           |
  | Vector-based    | No                 | O(n)        | Fast access, good for multiple swaps |

  Which to use?

  - Functional approach: When you want to keep the original list unchanged (most common in Lisp)
  - Destructive approach: When performance matters and you don't need the original list
  - Vector-based: When doing multiple index operations

  For most use cases, I recommend the clean and simple version above - it's functional, readable,
  and efficient enough for typical list sizes.

* Part III

#+begin_src elisp
  (defun process-directions (directions max-length)
    "Process list of direction strings. L subtracts, R adds."
    (seq-reduce
     (lambda (acc dir)
       (let* ((direction (substring dir 0 1))
              (number (string-to-number (substring dir 1))))
         (if (string= direction "L")
              (- acc number)
           (+ acc number) )))
     directions
     0))

  
  (defun swap-elements (lst i j)
    "Return new list with elements at indices I and J swapped."
    (let ((elem-i (nth i lst))
          (elem-j (nth j lst)))
      (mapcar (lambda (idx)
                (cond
                 ((= idx i) elem-j)
                 ((= idx j) elem-i)
                 (t (nth idx lst))))
              (number-sequence 0 (1- (length lst))))))


    (let* ((lines (with-temp-buffer
                    (insert-file-contents "../../data/2025/quest2.txt")
                    (split-string (buffer-string) "\n" t)))
           (first-line (car lines))
           (second-line (cadr lines))
           (first-parts (split-string first-line ","))
           (second-parts (split-string second-line ","))
           (names-len (length first-parts))
    	 )
      ;; Use first-parts and second-parts here
      ;;(message "First line parts: %S" first-parts)
     (message "Second line parts: %S" (nth (mod (process-directions second-parts (- names-len 1)) names-len) first-parts)
      ))  
#+end_src

